# Dynamic programming
Top-Down
- can calculate values as we go down the stack, storing it in the call itself, or in a local variable somewhere else.
- saving work to previous sub problems as you go.

bottom-up
- using a cache that builds up as we go
- subsequent answer is stored as you move up fib.
- **essentially, but is dynamic, saving work to previous sub problems as you go to avoid doing extra work.**

longest increasing subsequence
[1,5,2,6,10,4,20] => [1,2,6,10,20]

by knowing best one that ends in each index, we will know the best solution.  

Doing a perm in linear time is a good reason to use dynamic programming
- keep track of sub solutions
- each decision relies on relationship with subselections.

keeping track of highest possible as we move forward, looking back two away.
input:[1,5,16,20,3,7,10,5,10,25,17] = 62
maxes:[1,5,17,25,25(25 > 17+3),32, 35(25 + 10), 37, 45, 62, 62] both are highest
- as you move along, you take the record from the one that you chose.
 